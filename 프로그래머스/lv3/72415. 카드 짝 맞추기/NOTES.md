# 풀이 방법
1. board를 순회하며 카드의 위치를 Map 자료구조에(`targetMap`) 기록
	- 키: `카드 번호`
	- 값: `{ A: 위치, B: 위치 }`
	- 데이터 형식 예시
      ```js
      // borard
      [
        [1, 0, 0, 3],
        [2, 0, 0, 0],
        [0, 0, 0, 2],
        [3, 0, 1, 0],
      ]

      // targetMap
      Map(3) {  
        1 => { A: [ 0, 0 ], B: [ 3, 2 ] },  
        3 => { A: [ 0, 3 ], B: [ 3, 0 ] },  
        2 => { A: [ 1, 0 ], B: [ 2, 3 ] }  
      }
      ```

2. DFS를 이용하여 카드 방문 순서를 모두 구하기

3. 각 카드 방문 순서의 조작 최솟값 구하기 & 모든 순서의 조작 최솟값 구하기
	- 각 카드 방문 순서의 조작 최솟값
		- `source` 에서 `target` 좌표로 이동하는 2가지 경우의 수
			- 행 이동 후 열 이동
			- 열 이동 후 행 이동
		- 행 or 열 이동
			- 무조건 ctrl 이동을 하여 다음 좌표값(`next`)을 구하기 (=`getNextCtrlMove` 함수)
			- ctrl 이동을 반복할 때 다음 좌표값에 대한 2가지 경우의 수
				- `target` 좌표에 카드가 있어 `next`값과 동일한 경우
				- `target` 좌표에 카드가 없어 `next`값이 `target`을 지나친 경우
					- 지나친 곳에서 1칸씩 돌아가는 경우
					- 지나치기 전 좌표에서 1칸씩 나아가는 경우
	- 위 경우의 수를 모두 고려하면서 최솟값을 구하기

# 참고
[[프로그래머스] LV.3 카드 짝 맞추기 (JS)](https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.3-%EB%B6%88%EB%9F%89-%EC%82%AC%EC%9A%A9%EC%9E%90-JS-iz8d5d6k)
