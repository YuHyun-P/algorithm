# 풀이
문제 설명에서 나오는 **네트워크**는 그래프 상 연결 컴포넌트를 의미한다. 주어진 `computers` 무방향 그래프에서 연결 컴포넌트란 간선으로 연결된 정점끼리 모여 이루어진 서브 그래프이다. 같은 연결 컴포넌트에 속한 정점끼리는 경로가 존재하고, 다른 연결 컴포넌트의 정점과는 경로가 존재하지 않는다. 연결 컴포넌트는 보통 정점의 집합으로 표현한다.

<br />

1. 모든 정점을 시작점으로 순회하면서 연결된 정점들을 DFS 방법으로 방문한다. `visited` 방문 배열로 이미 다른 연결 컴포넌트에서 방문한 정점은 시작점으로 하지 않는다. (이 때 순회가 가능한 시작점의 개수와 연결 컴포넌트의 개수는 동일하다.)
3. DFS 방법으로 방문하는 경로를 `connectedComponent`에 저장하여 연결 컴포넌트를 구한다. (연결 컴포넌트의 개수를 구하는 문제이므로 `connectedComponent`에 저장하지 않아도 된다)
4. 연결 컴포넌트의 개수를 반환한다.

<br />

# 예시 
**입력값**
```
8, [
    [1, 0, 0, 1, 0, 0, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0],
    [0, 0, 1, 1, 0, 0, 0, 0],
    [1, 0, 1, 1, 0, 0, 0, 1],
    [0, 1, 0, 0, 1, 1, 0, 0],
    [0, 1, 0, 0, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 1, 0, 0, 0, 1],
  ]
```

**그래프**
![IMG_A9DDE72B6FF6-1](https://user-images.githubusercontent.com/96400112/189489329-d5fa64b3-dc28-4d0a-b31a-8121b0c86268.jpeg)

> `visited`를 코드에서는 정점 개수를 길이로 가지는 1차원 boolean 배열로 구현했지만, 풀이 예시에서는 알아보기 쉽도록 정점 값을 요소로 가지는 1차원 배열로 표현한다.

| `visited`                | `start` | `stack` | `connectedComponent` |
| ------------------------ | ------- | ------- | -------------------- |
| [0]                      | 0       | [0]     | []                   |
| [0, 3]                   | 0       | [3]     | [0]                  |
| [0, 3, 2, 7]             | 0       | [2, 7]  | [0, 3]               |
| [0, 3, 2, 7]             | 0       | [2]     | [0, 3, 7]            |
| [0, 3, 2, 7]             | 0       | []      | [0, 3, 7, 2]         |
| [0, 3, 2, 7, 1]          | 1       | [1]     | []                   |
| [0, 3, 2, 7, 1, 4, 5]    | 1       | [4, 5]  | [1]                  |
| [0, 3, 2, 7, 1, 4, 5]    | 1       | [4]     | [1, 5]               |
| [0, 3, 2, 7, 1, 4, 5]    | 1       | []      | [1, 5, 4]            |
| [0, 3, 2, 7, 1, 4, 5, 6] | 6       | [6]     | []                   |
| [0, 3, 2, 7, 1, 4, 5, 6] | 6       | []      | [6]                  |

# 참고
[연결 컴포넌트 connected component](https://aruz.tistory.com/11)
